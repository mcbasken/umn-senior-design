<h1>Chapter 4 (Page 2): Modeling Logic and Simulating Verilog Designs</h1>

<h2>Combinational Logic in Verilog</h2>

<p>Combinational logic refers to circuits where the output depends only on the current input values. In Verilog, this is typically modeled using:</p>
<ul>
  <li><strong>Continuous assignments</strong> with <code>assign</code></li>
  <li><strong>Procedural blocks</strong> with <code>always @(*)</code></li>
</ul>

<h3>Example: 4-to-1 Multiplexer Using <code>assign</code></h3>

<pre><code>```verilog
module mux4to1 (
    input [1:0] sel,
    input [3:0] in,
    output out
);
    assign out = (sel == 2'b00) ? in[0] :
                 (sel == 2'b01) ? in[1] :
                 (sel == 2'b10) ? in[2] :
                 in[3];
endmodule
```
</code></pre>

<h3>Example: 4-to-1 Multiplexer Using <code>always</code></h3>

<pre><code>```verilog
module mux4to1_proc (
    input [1:0] sel,
    input [3:0] in,
    output reg out
);
    always @(*) begin
        case (sel)
            2'b00: out = in[0];
            2'b01: out = in[1];
            2'b10: out = in[2];
            2'b11: out = in[3];
        endcase
    end
endmodule
```
</code></pre>

<hr>

<h2>Sequential Logic and Clocking</h2>

<p>Sequential circuits depend on both current inputs and past states, using clock signals to update values.</p>

<h3>Key Elements:</h3>
<ul>
  <li><strong>Flip-flops and Registers</strong> for state retention</li>
  <li><strong>Clock signals</strong> for synchronization</li>
  <li><strong>Reset signals</strong> to initialize states</li>
</ul>

<h3>Example: D Flip-Flop With Reset</h3>

<pre><code>```verilog
module dff (
    input clk,
    input reset,
    input d,
    output reg q
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule
```
</code></pre>

<hr>

<h2>Testbenches and Simulation</h2>

<p>Testbenches are used to <strong>verify Verilog modules</strong> by applying test inputs and monitoring outputs.</p>

<h3>Key Concepts:</h3>
<ul>
  <li>Use <code>initial</code> blocks to define input sequences</li>
  <li>Use <code>$display</code>, <code>$monitor</code>, or waveform tools to observe outputs</li>
  <li>Simulate edge cases, timing conditions, and expected outputs</li>
</ul>

<h3>Example: Simple Testbench for a D Flip-Flop</h3>

<pre><code>```verilog
module tb_dff;
    reg clk, reset, d;
    wire q;

    dff uut (.clk(clk), .reset(reset), .d(d), .q(q));

    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 10-time-unit clock period
    end

    initial begin
        reset = 1; d = 0;
        #12 reset = 0; d = 1;
        #10 d = 0;
        #10 d = 1;
        #20 $finish;
    end
endmodule
```
</code></pre>

<hr>

<div class="quiz">
  <h2 id="quiz">âœ… Quiz: Combinational and Sequential Logic in Verilog</h2>

  <p><strong>1. What is the primary difference between blocking and non-blocking assignments?</strong></p>
  <ul>
    <li>A) Blocking updates outputs immediately; non-blocking delays them</li>
    <li>B) Blocking can only be used in testbenches</li>
    <li>C) Non-blocking is used only for combinational logic</li>
    <li>D) They both behave the same in all cases</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: A) Blocking updates outputs immediately; non-blocking delays them</strong></p>
    <p>
      Explanation: Blocking (`=`) executes sequentially like software instructions,  
      while non-blocking (`<=`) schedules updates and is commonly used in sequential logic (e.g., `always_ff` style).
    </p>
  </details>

  <p><strong>2. Which keyword is used for a continuous assignment in Verilog?</strong></p>
  <ul>
    <li>A) <code>always</code></li>
    <li>B) <code>initial</code></li>
    <li>C) <code>assign</code></li>
    <li>D) <code>module</code></li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: C) <code>assign</code></strong></p>
    <p>
      Explanation: The <code>assign</code> keyword is used for continuous assignments in combinational logic.  
      It drives a wire with the result of an expression at all times.
    </p>
  </details>

  <p><strong>3. What does the following line do? <code>always @(posedge clk or posedge reset)</code></strong></p>
  <ul>
    <li>A) Triggers on both rising and falling edges</li>
    <li>B) Only sensitive to input changes</li>
    <li>C) Triggers only when both <code>clk</code> and <code>reset</code> are high</li>
    <li>D) Triggers on rising edge of <code>clk</code> or <code>reset</code></li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: D) Triggers on rising edge of <code>clk</code> or <code>reset</code></strong></p>
    <p>
      Explanation: This sensitivity list means the block executes on the rising edge of either the clock or the reset signal â€” common for synchronous resets.
    </p>
  </details>

  <p><strong>4. What is the purpose of a testbench in Verilog?</strong></p>
  <ul>
    <li>A) To design state machines</li>
    <li>B) To implement registers</li>
    <li>C) To verify module functionality</li>
    <li>D) To generate clock signals only</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: C) To verify module functionality</strong></p>
    <p>
      Explanation: A testbench simulates a design by applying inputs and checking outputs â€” it verifies that your Verilog module behaves as expected.
    </p>
  </details>

  <p><strong>5. In a 4-to-1 multiplexer, how many select lines are needed?</strong></p>
  <ul>
    <li>A) 1</li>
    <li>B) 2</li>
    <li>C) 3</li>
    <li>D) 4</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: B) 2</strong></p>
    <p>
      Explanation: A 4-to-1 multiplexer selects 1 of 4 inputs. You need <strong>logâ‚‚(4) = 2</strong> select lines.
    </p>
  </details>
</div>

<hr>

<h2>ðŸ§ª MicroSim Prompt</h2>

<h3>ðŸŽ¯ Simulation Prompt: 4-to-1 Multiplexer with Testbench</h3>

<p><strong>Design and simulate a 4-to-1 multiplexer in Verilog.</strong> Then write a testbench to verify that each input is correctly routed to the output based on the select signal.</p>

<h4>Functional Requirements:</h4>
<ul>
  <li>Inputs: <code>in[3:0]</code>, <code>sel[1:0]</code></li>
  <li>Output: <code>out</code></li>
  <li>The testbench should:
    <ul>
      <li>Apply all possible select values (<code>00</code>, <code>01</code>, <code>10</code>, <code>11</code>)</li>
      <li>Cycle through input combinations (e.g., <code>4'b1000</code>, <code>4'b0100</code>, etc.)</li>
      <li>Verify correct routing by observing <code>out</code></li>
    </ul>
  </li>
</ul>

<h4>MicroSim Setup:</h4>
<ul>
  <li>Design the multiplexer module using both <code>assign</code> and <code>always</code> styles (optional).</li>
  <li>Create a waveform or simulation log using <code>$monitor</code> or <code>$display</code>.</li>
</ul>

<p>ðŸ“Œ <strong>Learning Outcome:</strong><br>
Practice combinational design, Verilog syntax, and how to create and simulate a functional testbench.
</p>
