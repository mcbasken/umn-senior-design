<h1>Chapter 4 (Page 2): Modeling Logic and Simulating Verilog Designs</h1>

<h2>Combinational Logic in Verilog</h2>

<p>Combinational logic refers to circuits where the output depends only on the current input values. In Verilog, this is typically modeled using:</p>
<ul>
  <li><strong>Continuous assignments</strong> with <code>assign</code></li>
  <li><strong>Procedural blocks</strong> with <code>always @(*)</code></li>
</ul>

<h3>Example: 4-to-1 Multiplexer Using <code>assign</code></h3>

<pre><code>```verilog
module mux4to1 (
    input [1:0] sel,
    input [3:0] in,
    output out
);
    assign out = (sel == 2'b00) ? in[0] :
                 (sel == 2'b01) ? in[1] :
                 (sel == 2'b10) ? in[2] :
                 in[3];
endmodule
```
</code></pre>

<h3>Example: 4-to-1 Multiplexer Using <code>always</code></h3>

<pre><code>```verilog
module mux4to1_proc (
    input [1:0] sel,
    input [3:0] in,
    output reg out
);
    always @(*) begin
        case (sel)
            2'b00: out = in[0];
            2'b01: out = in[1];
            2'b10: out = in[2];
            2'b11: out = in[3];
        endcase
    end
endmodule
```
</code></pre>

<hr>

<h2>Sequential Logic and Clocking</h2>

<p>Sequential circuits depend on both current inputs and past states, using clock signals to update values.</p>

<h3>Key Elements:</h3>
<ul>
  <li><strong>Flip-flops and Registers</strong> for state retention</li>
  <li><strong>Clock signals</strong> for synchronization</li>
  <li><strong>Reset signals</strong> to initialize states</li>
</ul>

<h3>Example: D Flip-Flop With Reset</h3>

<pre><code>```verilog
module dff (
    input clk,
    input reset,
    input d,
    output reg q
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule
```
</code></pre>

<hr>

<h2>Testbenches and Simulation</h2>

<p>Testbenches are used to <strong>verify Verilog modules</strong> by applying test inputs and monitoring outputs.</p>

<h3>Key Concepts:</h3>
<ul>
  <li>Use <code>initial</code> blocks to define input sequences</li>
  <li>Use <code>$display</code>, <code>$monitor</code>, or waveform tools to observe outputs</li>
  <li>Simulate edge cases, timing conditions, and expected outputs</li>
</ul>

<h3>Example: Simple Testbench for a D Flip-Flop</h3>

<pre><code>```verilog
module tb_dff;
    reg clk, reset, d;
    wire q;

    dff uut (.clk(clk), .reset(reset), .d(d), .q(q));

    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 10-time-unit clock period
    end

    initial begin
        reset = 1; d = 0;
        #12 reset = 0; d = 1;
        #10 d = 0;
        #10 d = 1;
        #20 $finish;
    end
endmodule
```
</code></pre>

<hr>

<h2>âœ… Quiz: Combinational and Sequential Logic in Verilog</h2>

<ol>
  <li><strong>What is the primary difference between blocking and non-blocking assignments?</strong><br>
    a. Blocking updates outputs immediately; non-blocking delays them<br>
    b. Blocking can only be used in testbenches<br>
    c. Non-blocking is used only for combinational logic<br>
    d. They both behave the same in all cases
  </li>
  <li><strong>Which keyword is used for a continuous assignment in Verilog?</strong><br>
    a. <code>always</code><br>
    b. <code>initial</code><br>
    c. <code>assign</code><br>
    d. <code>module</code>
  </li>
  <li><strong>What does the following line do? <code>always @(posedge clk or posedge reset)</code></strong><br>
    a. Triggers on both rising and falling edges<br>
    b. Only sensitive to input changes<br>
    c. Triggers only when both clk and reset are high<br>
    d. Triggers on rising edge of clk or reset
  </li>
  <li><strong>What is the purpose of a testbench in Verilog?</strong><br>
    a. To design state machines<br>
    b. To implement registers<br>
    c. To verify module functionality<br>
    d. To generate clock signals only
  </li>
  <li><strong>In a 4-to-1 multiplexer, how many select lines are needed?</strong><br>
    a. 1<br>
    b. 2<br>
    c. 3<br>
    d. 4
  </li>
</ol>

<p><strong>Answers:</strong><br>
1. a<br>
2. c<br>
3. d<br>
4. c<br>
5. b</p>

<hr>

<h2>ðŸ§ª MicroSim Prompt</h2>

<h3>ðŸŽ¯ Simulation Prompt: 4-to-1 Multiplexer with Testbench</h3>

<p><strong>Design and simulate a 4-to-1 multiplexer in Verilog.</strong> Then write a testbench to verify that each input is correctly routed to the output based on the select signal.</p>

<h4>Functional Requirements:</h4>
<ul>
  <li>Inputs: <code>in[3:0]</code>, <code>sel[1:0]</code></li>
  <li>Output: <code>out</code></li>
  <li>The testbench should:
    <ul>
      <li>Apply all possible select values (<code>00</code>, <code>01</code>, <code>10</code>, <code>11</code>)</li>
      <li>Cycle through input combinations (e.g., <code>4'b1000</code>, <code>4'b0100</code>, etc.)</li>
      <li>Verify correct routing by observing <code>out</code></li>
    </ul>
  </li>
</ul>

<h4>MicroSim Setup:</h4>
<ul>
  <li>Design the multiplexer module using both <code>assign</code> and <code>always</code> styles (optional).</li>
  <li>Create a waveform or simulation log using <code>$monitor</code> or <code>$display</code>.</li>
</ul>

<p>ðŸ“Œ <strong>Learning Outcome:</strong><br>
Practice combinational design, Verilog syntax, and how to create and simulate a functional testbench.
</p>
