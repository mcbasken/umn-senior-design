<h1>Chapter 3: Designing FSMs and Memory Integration</h1>

<h2>FSM Design and Verilog Implementation</h2>

<p>Designing a Finite State Machine (FSM) involves defining a set of states, identifying the inputs that affect transitions, and determining the outputs. The design process typically includes the following steps:</p>

<ol>
  <li><strong>Define the States</strong><br>Clearly label each state and assign it a binary encoding.</li>
  <li><strong>Draw the State Diagram</strong><br>Use circles for states and arrows for transitions, labeled with input/output conditions.</li>
  <li><strong>Create the State Table</strong><br>Convert the diagram into a table showing current states, inputs, next states, and outputs.</li>
  <li><strong>Implement in Verilog</strong><br>Use <code>always</code> blocks, <code>case</code> statements, and state registers to model the FSM.</li>
</ol>

<h3>Example: Simple Traffic Light Controller (Moore Machine)</h3>

<pre><code class="language-verilog">
module traffic_light (
    input clk, reset,
    output reg [1:0] light
);
    typedef enum reg [1:0] {RED, GREEN, YELLOW} state_t;
    state_t current_state, next_state;

    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset)
            current_state &lt;= RED;
        else
            current_state &lt;= next_state;
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            RED:    next_state = GREEN;
            GREEN:  next_state = YELLOW;
            YELLOW: next_state = RED;
            default: next_state = RED;
        endcase
    end

    // Output logic
    always @(*) begin
        case (current_state)
            RED:    light = 2'b00;
            GREEN:  light = 2'b01;
            YELLOW: light = 2'b10;
        endcase
    end
endmodule
</code></pre>

<hr>

<h2>Integrating FSMs with Memory</h2>

<p>FSMs can also control memory operations, such as <strong>read/write control</strong>, <strong>address sequencing</strong>, or <strong>data validation</strong>. In a typical digital system, an FSM may:</p>

<ul>
  <li>Select between memory modules (e.g., ROM vs. RAM)</li>
  <li>Control memory timing signals</li>
  <li>Track memory address pointers for reads/writes</li>
  <li>Trigger interrupts or wait states based on memory flags</li>
</ul>

<h3>Example: FSM Controlling a Simple Memory Read Process</h3>

<p>A <strong>Mealy FSM</strong> can be used to initiate a read from memory only when a <code>read_enable</code> signal is asserted. This allows for outputs that depend on both <strong>current state</strong> and <strong>input conditions</strong>.</p>

<hr>

<h2>Memory Addressing and Timing</h2>

<p>Memory is accessed using <strong>address lines</strong>, which specify the location of data. The process of reading or writing data requires careful coordination of:</p>

<ul>
  <li><strong>Address setup time</strong></li>
  <li><strong>Read/write enable signals</strong></li>
  <li><strong>Clock synchronization</strong></li>
</ul>

<p>Modern systems often include <strong>memory controllers</strong> managed by FSMs to ensure proper timing and sequencing.</p>

<hr>

<div class="quiz">
  <h2 id="quiz">Quiz: Check Your Understanding</h2>

  <p><strong>1. What is the output of a D flip-flop when D = 1 and a rising clock edge occurs?</strong></p>
  <ul>
    <li>A) 0</li>
    <li>B) It toggles</li>
    <li>C) 1</li>
    <li>D) No change</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: C) 1</strong></p>
    <p>
      A D flip-flop transfers the value of <code>D</code> to the output on a rising clock edge.  
      Since <code>D = 1</code>, the output becomes <strong>1</strong>.
    </p>
  </details>

  <p><strong>2. Which flip-flop toggles its output when both inputs are 1?</strong></p>
  <ul>
    <li>A) D flip-flop</li>
    <li>B) SR flip-flop</li>
    <li>C) JK flip-flop</li>
    <li>D) T flip-flop</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: C) JK flip-flop</strong></p>
    <p>
      The JK flip-flop toggles its output when both <code>J</code> and <code>K</code> inputs are <strong>1</strong> at the clock edge.
    </p>
  </details>

  <p><strong>3. How many D flip-flops are required to build an 8-bit register?</strong></p>
  <ul>
    <li>A) 4</li>
    <li>B) 8</li>
    <li>C) 16</li>
    <li>D) 1</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: B) 8</strong></p>
    <p>
      Each D flip-flop stores <strong>1 bit</strong>. An 8-bit register therefore requires <strong>8 D flip-flops</strong>.
    </p>
  </details>

  <p><strong>4. True or False: Flip-flops are used only in combinational logic circuits.</strong></p>
  <ul>
    <li>A) True</li>
    <li>B) False</li>
  </ul>
  <details>
    <summary>Show Answer</summary>
    <p><strong>Correct answer: B) False</strong></p>
    <p>
      Flip-flops are the core of <strong>sequential logic</strong>, not combinational logic.  
      They store state, enabling memory and time-dependent behavior.
    </p>
  </details>
</div>


<hr>

<h2>ðŸ§ª MicroSim Prompt</h2>

<h3>ðŸŽ¯ Simulation Prompt: FSM-Controlled Memory Reader</h3>

<p><strong>Design and simulate a Mealy FSM</strong> that performs the following:</p>
<ul>
  <li>Waits for a <code>start_read</code> input signal</li>
  <li>Cycles through a memory address range (e.g., <code>0x00</code> to <code>0x0F</code>)</li>
  <li>Asserts <code>read_enable</code> and outputs the address</li>
  <li>Goes to an idle state after all addresses have been read</li>
</ul>

<h3>MicroSim Requirements</h3>

<ul>
  <li><strong>Inputs:</strong> <code>clk</code>, <code>reset</code>, <code>start_read</code></li>
  <li><strong>Outputs:</strong> <code>address</code>, <code>read_enable</code></li>
  <li><strong>Optional:</strong> Simulate a simple memory module with fixed data for readout</li>
</ul>

<p>ðŸ“Œ <strong>Learning Outcome:</strong> Understand how FSMs manage sequential memory access with proper timing and control.</p>

